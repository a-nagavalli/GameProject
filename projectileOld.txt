class Projectile : public Entity
{
	private:
		Uint64 startMoveTime, endMoveTime;
		Uint64 currTime, lastTime;
		bool greaterX, greaterY;
		int xDelay, yDelay;
		int targetUpdateDelay;
		int targetXPos, targetYPos;
		int deltaX, deltaY;



		//Entity& target;
		



	public:
		Projectile(const std::string& argPath, SDL_Renderer* const& argRenderer, int xPos, int yPos, int width, int height, Entity argTarget)
			: Entity(argPath, argRenderer, xPos, yPos, width, height)//,					target(argTarget)
		{
			startMoveTime = endMoveTime = 0;
			currTime = lastTime = 0;
			greaterX = greaterY = false;
			xDelay = yDelay = 0;
			targetUpdateDelay = 0;
			targetXPos = targetYPos = 0;
			deltaX = deltaY = 0;
		}

		void Update(Uint64 deltaTime, Entity& target)
		{
			updateMovementBools(deltaTime);
			updatePositionSmooth(target);
		}

		void setTargetUpdateDelay(Uint64 num)
		{
			targetUpdateDelay = num;
			lastTime = num;
		}

		void updatePositionSmooth(Entity& target)		// note that this function is called every pass through the main game loop
		{
			moveToSmooth(target);
		}

		bool moveToSmooth(Entity& target)		// this will only get the sprite close to the target position (not exact) in the approximate length of time
		{
			currTime = SDL_GetTicks64();

			if ((currTime - lastTime) > targetUpdateDelay) {

				deltaX = abs(sprite.rect.x - target.sprite.rect.x);		// distance needed to travel
				deltaY = abs(sprite.rect.y - target.sprite.rect.y);

				xDelay = int(round(2000 * 1.0 / deltaX));	
				yDelay = int(round(2000 * 1.0 / deltaY));

				movingDown = movingUp = movingLeft = movingRight = false;

				targetXPos = target.sprite.rect.x;
				targetYPos = target.sprite.rect.y;

				greaterX = sprite.rect.x > target.sprite.rect.x;	// change direction if needed
				greaterY = sprite.rect.y > target.sprite.rect.y;

				lastTime = currTime;
			}


			// doing this for each possible combination of where the sprite is currently located in relation to where it needs to go
			if (!greaterX && !greaterY) {
				if (sprite.rect.x <= targetXPos && sprite.rect.y <= targetYPos) {	// this will produce smooth movement because the sprite will keep moving until both coordinates have reached or exceeded their destinations
					startMoveTime = SDL_GetTicks64();

					deltaX = abs(sprite.rect.x - target.sprite.rect.x);		// distance needed to travel
					deltaY = abs(sprite.rect.y - target.sprite.rect.y);

					xDelay = sqrt(int(round(2000 * 1.0 / deltaX))) * 1.5;	// having xDelay and yDelay proportional to distance remaining produces a curved trajectory for the projectile
					yDelay = sqrt(int(round(2000 * 1.0 / deltaY))) * 1.5;

					if (xDelay > 12)		// but don't let the delays get too high (projectile shouldn't move too slowly)
						xDelay = 12;
					if (yDelay > 12)
						yDelay = 12;

					setMoveSpeedX(1);
					setMoveSpeedY(1);
					setMoveSpeedDelayX(xDelay);
					setMoveSpeedDelayY(yDelay);

					movingRight = true;
					movingDown = true;
				}

				if (sprite.rect.x >= targetXPos && sprite.rect.y >= targetYPos) {
					endMoveTime = SDL_GetTicks64();

					setMoveSpeedX(1);	// reset
					setMoveSpeedY(1);
					setMoveSpeedDelayX(15);
					setMoveSpeedDelayY(15);

					movingRight = false;
					movingDown = false;




					// ********************ASDF***********************************************ASDF
					shouldBeDestroyed = true;
					target.shouldBeDestroyed = true;



					return true;
				}
			}

			if (greaterX && !greaterY) {
				if (sprite.rect.x >= targetXPos && sprite.rect.y <= targetYPos) {
					startMoveTime = SDL_GetTicks64();

					deltaX = abs(sprite.rect.x - target.sprite.rect.x);
					deltaY = abs(sprite.rect.y - target.sprite.rect.y);

					xDelay = sqrt(int(round(2000 * 1.0 / deltaX))) * 1.5;	
					yDelay = sqrt(int(round(2000 * 1.0 / deltaY))) * 1.5;

					if (xDelay > 12)
						xDelay = 12;
					if (yDelay > 12)
						yDelay = 12;

					setMoveSpeedX(1);
					setMoveSpeedY(1);
					setMoveSpeedDelayX(xDelay);
					setMoveSpeedDelayY(yDelay);

					movingLeft = true;
					movingDown = true;
				}

				if (sprite.rect.x <= targetXPos && sprite.rect.y >= targetYPos) {
					endMoveTime = SDL_GetTicks64();

					setMoveSpeedX(1);	// reset
					setMoveSpeedY(1);
					setMoveSpeedDelayX(15);
					setMoveSpeedDelayY(15);

					movingLeft = false;
					movingDown = false;




					// ********************ASDF***********************************************ASDF
					shouldBeDestroyed = true;
					target.shouldBeDestroyed = true;




					return true;
				}
			}

			if (!greaterX && greaterY) {
				if (sprite.rect.x <= targetXPos && sprite.rect.y >= targetYPos) {
					startMoveTime = SDL_GetTicks64();

					deltaX = abs(sprite.rect.x - target.sprite.rect.x);
					deltaY = abs(sprite.rect.y - target.sprite.rect.y);

					xDelay = sqrt(int(round(2000 * 1.0 / deltaX))) * 1.5;	
					yDelay = sqrt(int(round(2000 * 1.0 / deltaY))) * 1.5;

					if (xDelay > 12)
						xDelay = 12;
					if (yDelay > 12)
						yDelay = 12;

					setMoveSpeedX(1);
					setMoveSpeedY(1);
					setMoveSpeedDelayX(xDelay);
					setMoveSpeedDelayY(yDelay);

					movingRight = true;
					movingUp = true;
				}

				if (sprite.rect.x >= targetXPos && sprite.rect.y <= targetYPos) {
					endMoveTime = SDL_GetTicks64();

					setMoveSpeedX(1);	// reset
					setMoveSpeedY(1);
					setMoveSpeedDelayX(15);
					setMoveSpeedDelayY(15);

					movingRight = false;
					movingUp = false;




					// ********************ASDF***********************************************ASDF
					shouldBeDestroyed = true;
					target.shouldBeDestroyed = true;




					return true;
				}
			}

			if (greaterX && greaterY) {
				if (sprite.rect.x >= targetXPos && sprite.rect.y >= targetYPos) {
					startMoveTime = SDL_GetTicks64();

					deltaX = abs(sprite.rect.x - target.sprite.rect.x);
					deltaY = abs(sprite.rect.y - target.sprite.rect.y);

					xDelay = sqrt(int(round(2000 * 1.0 / deltaX))) * 1.5;	
					yDelay = sqrt(int(round(2000 * 1.0 / deltaY))) * 1.5;

					if (xDelay > 12)
						xDelay = 12;
					if (yDelay > 12)
						yDelay = 12;

					setMoveSpeedX(1);
					setMoveSpeedY(1);
					setMoveSpeedDelayX(xDelay);
					setMoveSpeedDelayY(yDelay);

					movingLeft = true;
					movingUp = true;
				}

				if (sprite.rect.x <= targetXPos && sprite.rect.y <= targetYPos) {
					endMoveTime = SDL_GetTicks64();

					setMoveSpeedX(1);	// reset
					setMoveSpeedY(1);
					setMoveSpeedDelayX(15);
					setMoveSpeedDelayY(15);

					movingLeft = false;
					movingUp = false;




					// ********************ASDF***********************************************ASDF
					shouldBeDestroyed = true;
					target.shouldBeDestroyed = true;




					return true;
				}
			}

			return false;	// movement hasn't yet completed
		}

};